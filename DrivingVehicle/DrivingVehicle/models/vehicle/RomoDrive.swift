////  RomoDrive.swift//  DrivingVehicle//import Foundationimport AVFoundationpublic class RomoDrive: VehicleTemplate, RMCoreDelegate, AVAudioPlayerDelegate{    private var _robot: RMCoreRobotRomo3? = nil    private var cannonPlayer : AVAudioPlayer!    private var _socket: Skyway?    init(socket: Skyway){        super.init()        _socket = socket        RMCore.setDelegate(self)        let cannonfileURL: NSURL = NSURL(fileURLWithPath: NSBundle.mainBundle().pathForResource("cannon", ofType: "mp3")!)        do {            cannonPlayer = try AVAudioPlayer(contentsOfURL: cannonfileURL)        } catch _ {            cannonPlayer = nil        }        cannonPlayer.delegate = self        cannonPlayer.prepareToPlay()    }    func dispatch_async_main(block: () -> ()) {        dispatch_async(dispatch_get_main_queue(), block)    }    // MARK: RMCoreDelegate    public func robotDidConnect(robot: RMCoreRobot!) {        if (robot.isKindOfClass(RMCoreRobotRomo3)) {            self.dispatch_async_main {                self._robot = robot as? RMCoreRobotRomo3                self._robot?.tiltByAngle(130.0, completion: nil)            }        }    }    public func robotDidDisconnect(robot: RMCoreRobot!) {        if (robot == _robot) {            _robot = nil;        }    }    // MARK: VehicleTemplate    override func driveForward() {        if (_robot?.respondsToSelector("driveForwardWithSpeed:") == true) {            self.dispatch_async_main {                self._robot?.driveForwardWithSpeed(0.5)            }        }    }    override func driveBackward(){        if (_robot?.respondsToSelector("driveBackwardWithSpeed:") == true) {            self.dispatch_async_main {                self._robot?.driveBackwardWithSpeed(0.5)            }        }    }    override func rotateLeft(){        if (_robot?.respondsToSelector("driveWithRadius:speed:") == true) {            self.dispatch_async_main {                self._robot?.driveWithRadius(0.1, speed: 0.5)            }        }    }    override func rotateRight(){        if (_robot?.respondsToSelector("driveWithRadius:speed:") == true) {            self.dispatch_async_main {                self._robot?.driveWithRadius(0.1, speed: -0.5)            }        }    }    override func driveDiagonallyForwardLeft(){        if (_robot?.respondsToSelector("driveWithRadius:speed:") == true) {            self.dispatch_async_main {                self._robot?.driveWithRadius(0.7, speed: 0.5)            }        }    }    override func driveDiagonallyForwardRight(){        if (_robot?.respondsToSelector("driveWithRadius:speed:") == true) {            self.dispatch_async_main {                self._robot?.driveWithRadius(-0.7, speed: 0.5)            }        }    }    override func driveDiagonallyBackwardLeft(){        if (_robot?.respondsToSelector("driveWithRadius:speed:") == true) {            self.dispatch_async_main {                self._robot?.driveWithRadius(0.7, speed: -0.5)            }        }    }    override func driveDiagonallyBackwardRight(){        if (_robot?.respondsToSelector("driveWithRadius:speed:") == true) {            self.dispatch_async_main {                self._robot?.driveWithRadius(-0.7, speed: -0.5)            }        }    }    override func stopDriving(){        if (_robot?.respondsToSelector("stopDriving") == true) {            self.dispatch_async_main {                self._robot?.stopDriving()            }        }    }    override func headingUp(){        if (_robot?.respondsToSelector("tiltToAngle:completion:") == true) {            self.dispatch_async_main {                self._robot?.tiltToAngle(130.0, completion: nil)            }        }    }    override func headingDonw(){        if (_robot?.respondsToSelector("tiltToAngle:completion:") == true) {            self.dispatch_async_main {                self._robot?.tiltToAngle(70.0, completion: nil)            }        }    }    override func stopHeading() {        if (_robot?.respondsToSelector("stopTilting") == true) {            self.dispatch_async_main {                self._robot?.stopTilting()            }        }    }    override func button6(){        if(cannonPlayer != nil){            if (cannonPlayer.playing == true) {                cannonPlayer.currentTime = 0;            }            cannonPlayer.play()        }    }    override func battery() {        let currentDevice: UIDevice! = UIDevice.currentDevice()        var romo_battery: Float = 0        var ios_battery: Float = 0        if let robot = _robot {            romo_battery = robot.vitals.batteryLevel            if let unwrapDevice = currentDevice {                unwrapDevice.batteryMonitoringEnabled = true                ios_battery = unwrapDevice.batteryLevel                    let send_dict: Dictionary = [                    "VehicleBattery": Double(romo_battery),                    "IOSBattery": Double(ios_battery)                ]                _socket?.send(send_dict)            }        }    }    // MARK: AVAudioPlayerDelegate    public func audioPlayerDidFinishPlaying(player: AVAudioPlayer, successfully flag: Bool) {    }    public func audioPlayerDecodeErrorDidOccur(player: AVAudioPlayer, error: NSError?) {    }}